// перечисление скобочных выражений из '(',')','[',']'
// вывод fputc
//#include "stdafx.h"
#include <iostream>   
#include <fstream>
#include <ctime>

const int DL = 30;      // максимальная длина строки из скобок

using namespace std;

int main()
{
    clock_t t = clock();
    int count = 0;
    char s[DL];   //текущая строка из скобок
    char st[DL];  //стек для проверки вложенности скобок
    char tek[DL], znak[DL];
    // tek и znak - изменения в стеке для его восстановления после 
    // предыдущих удалений,  индекс - номер позиции
    // пример: +( - добавление к стеку на шаге, -[ - удаление скобки
    int p;         // вершина стека
    int sc[DL];
    // для перебора по видам скобок в каждой позиции строки:
    // 1 - '(', 2 - '[', 3 - ')', 4 -']'
    int n;         // длина строки 
    int i, j, k;   // i - позиция в строке, k - глубина вложения строк
    FILE *Fin = fopen("input.txt", "r");
    if (Fin == NULL )
    {
         printf("\nCan not open file");
         getchar();
	 return -1;
    } 
    fscanf(Fin, "%d", &n);
    fclose(Fin);
	for (i = 1; i <= n; i++) sc[i] = 0;
    i = 1;   // позиция в строке вывода - от 1 до n
    k = 0;   // глубина
    p = -1;  // вершина стека
    FILE* Fout = fopen("output.txt", "w");
    while (i > 0)
    {
        if (i == (n + 1)) // очередная строка сформирована, стек пуст, глубина 0
        {
			for (j = 1; j <= n; j++) fputc(s[j], Fout);
            count++;
            fprintf(Fout, "\n");
            k = 1;       // без закрывающей скобки глубина 1
            i = n;
            p = 0;       // вершина стека
            if (s[n] == ')') st[p] = '(';
            else st[p] = '[';
        }
        sc[i]++;    // переход к следующему виду скобок
        switch (sc[i])
        {
            case 1:    // можно ли в позицию i ставить "(" ?
                 if ((n - i) >= (k + 1))  // можно - k позиций потребуется для закрывающих
                 {
                     s[i] = '(';
                     tek[i - 1] = '(';     // можно убрать
                     znak[i - 1] = '+';
                     st[++p] = '(';
                     sc[++i] = 0;
                     k++;                  // увеличение глубины
                 }
				 break;
			case 2:    // можно ли в позицию i ставить "(" ?
                 if ((n - i) >= (k + 1))  // можно - k позиций потребуется для закрывающих
                 {
                     s[i] = '[';
                     tek[i - 1] = '[';     // можно убрать
                     znak[i - 1] = '+';
                     st[++p] = '[';
                     sc[++i] = 0;
                     k++;                  // увеличение глубины
                 }
				 break;
			case 3:    // можно ли в позицию i ставить ")" ?
                 if ((p >= 0) &&  (st[p] == '(')) // можно
                 {
                     s[i] = ')';
                     tek[i - 1] = '(';     
                     znak[i - 1] = '-';
                     k--;                  // уменьшение глубины скобок
                     p--;                  // удаление из стека
                     sc[++i] = 0;
                 }
				 break;
			case 4:    // можно ли в позицию i ставить "]" ?
                 if ((p >= 0) &&  (st[p] == '[')) // можно
                 {
                     s[i] = ']';
                     tek[i - 1] = '[';     
                     znak[i - 1] = '-';
                     k--;                  // уменьшение глубины скобок
                     p--;                  // удаление из стека
                     sc[++i] = 0;
                 }
				 break;
			case 5:    // для позиции i перебрали все варианты
                 sc[i--] = 0;             // возврат в предыдущую позицию
                 if (i > 0)
                 {
                     if ((s[i] == '(') || (s[i] == '[')) k--;
                     // новый выбор вместо открывающей скобки
                     if ((s[i] == ')') || (s[i] == ']')) k++;
                     // новый выбор вместо закрывающей скобки
                     if (znak[i - 1] == '+') p--;    // стек увеличивался
                     else                             // стек уменьшался
                     {
                         p++;  
                         if (tek[i - 1] == '(') st[p] = '(';
                         else st[p] = '[';            // восстановление старого состояния стека
                     }
                 }
				 break;
		}             // switch
    }                 // while
    fclose(Fin);
    cout << "Elements count: " << count;
    cout << "    Run time = " << (float)(clock() - t) / CLOCKS_PER_SEC << endl;
    return 0;
}
