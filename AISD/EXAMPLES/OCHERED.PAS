{     Дан список  клиентов,  желающих посетить банк в некоторый
период времени. Для каждого клиента заданы имя, момент прихода
и время обслуживания. В банке работает один кассир. Если в мо-
мент прихода очередного клиента кассир  занят,  клиент  стано-
вится  в  очередь.  Обслуженный кассиром клиент покидает банк.
Требуется промоделировать работу кассира, т.е. последовательно
выдать информацию о приходах и уходах клиентов из банка с ука-
занием состояния очереди. Необходимо также найти среднее время
обслуживания клиента.
     Будем считать,  что список упорядочен по возрастанию  мо-
ментов прихода  клиентов.  При  работе  банка  встречается два
класса событий:
     1) приход клиента и постановка его в очередь (если кассир
не занят,  то очередь будет состоять только из пришедшего кли-
ента);
     2) сокращение очереди.
     Пусть имеется N клиентов.  Обозначим  через  M[i]  момент
прихода,   а  через  T[i]  время  обслуживания  i-го  клиента.
Рассмотрим алгоритм решения задачи.
     1. S:=0 - общее время обслуживания клиентов.
     2. R:=M[1]+T[1] - момент разгрузки очереди.
     3. i:=1  - начало цикла по клиентам до i=N.
     4. P:=M[i], где P - момент прихода очередного клиента.
     5. Если  P>=R  (приход  клиента после ближайшей разгрузки
        очереди) и очередь не пуста, то:
        1) S:=S+R-M[j], где j-номер клиента из начала очереди;
        2) разгрузить очередь,  убрав клиента из ее начала,  и
           выдать сообщение на экран;
        3) если очередь не пуста, то
           R:=R+T[j+1] - следующий момент разгрузки очереди;
        4) переход к шагу 6.
     6. Если очередь пуста, то
           R:=M[i]+T[i].
     7. Постановка в  очередь i-го клиента и  выдача  соответ-
        ствующего сообщения.
     8. i:=i+1; если i<=N, то переход к шагу 4.
     9. Если очередь не пуста, то  ее полная разгрузка с выда-
        чей сообщений.
    10. H:=S/N - среднее время обслуживания клиента.
    11. Выдача H; конец.

     Приведем текст  программы.  Очередь реализована с помощью
массива. Начало очереди соответствует первому элементу  масси-
ва, а конец - последнему элементу.
}
Program Ochered;
  uses crt;
  Label e;
  Type
    stri=string[20];
    klient=record
             name: stri;        { имя }
             m: integer;        { момент прихода }
             t: integer         { время обслуживания }
           end;
  Var
    h: real;  { среднее время обслуживания клиента }
    i,j,r,s,p,n,l: integer;
    och: array [1..100] of integer; { очередь }
    bego,endo: integer;             { начало и конец очереди }
    kli: array [1..100] of klient;
    { список клиентов по возрастанию моментов прихода }
  Procedure Razgruz;
    Begin
      j:=och[bego]; { номер клиента из начала очереди }
      s:=s+r-kli[j].m;
      { учли время его нахождения в очереди }
      Write('Время: ',r,', обслужен клиент ',
        kli[j].name);
      endo:=endo-1;               { разгрузка очереди }
      For l:=bego to endo do
        och[l]:=och[l+1];
      if endo>0 then                { очередь не пуста }
        begin
          Writeln(', следующий клиент ',kli[j+1].name);
          r:=r+kli[j+1].t
          { следующий момент разгрузки }
        end
      else Writeln(', очередь пуста !');
      Readln                     { пауза }
    End;
  Begin
    Clrscr;  { очистка экрана }
    For n:=1 to 100 do
      begin
        with kli[n] do
          begin
            Writeln('Введите информацию об очередном клиенте:');
            Write('Введите имя (к-признак конца): ');
            Readln(name);
            if name='к' then goto e; { конец списка клиентов }
            Write('Укажите момент прихода: ');
            Readln(m);
            Write('Сообщите время обслуживания: ');
            Readln(t)
          end
      end;
e:  Writeln;
    Writeln('   ПРОТОКОЛ РАБОТА БАНКА');
    n:=n-1;         { число клиентов }
    s:=0;           { для общего времени обслуживания }
    bego:=1;        { начало очереди всегда здесь ! }
    endo:=0;        { критерий пустой очереди }
    r:=0;
    { ближайший момент разгрузки очереди }
    For i:=1 to n do
      begin
        p:=kli[i].m;   { момент прихода следующего клиента }
        While (p>=r) and (endo>0)  do
          Razgruz;
        { очередь сокращается до прихода следующего клиента }
        { и больше не разгружается                          }
        if endo=0 then r:=kli[i].m+kli[i].t;
        { следующий момент разгрузки }
        endo:=endo+1; { постановка в очередь i-го клиента }
        och[endo]:=i;
        Write('Время: ',kli[i].m,', прибыл клиент ',
                 kli[i].name);
        if endo=1 then
          Writeln(', очереди нет, ура !')
        else
          Writeln(', встал в очередь за клиентом ',
                   kli[och[endo-1]].name);
        Readln       { пауза }
      end;
      While endo>0  do
        Razgruz;
      h:=s/n;
      Writeln('Обслуживание закончено, перерыв на обед !');
      Writeln('Среднее время обслуживания клиента: ',h:5:2);
      Readln           { пауза }
   End.
